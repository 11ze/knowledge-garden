---

title: 04｜深入浅出索引（上）
tags:
- MySQL
publishDate: 2023-05-17T10:09:25+08:00
mindmap-plugin: basic

---

- 每遇到一个新数据库，先关注它的数据模型，分析数据库的适用场景
- 数据库底层存储的核心基于的数据模型：哈希表、有序数组、二叉树、N 叉树等
- 哈希表
  - 以键 - 值（key-value）存储数据的结构
  - 思路：把值放到数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置
  - 不可避免出现哈希冲突，其中一种解决方法是用链表存储相同 key 的值，查找时从链表头开始按顺序遍历链表
  - 适用于只有等值查询的场景
    - 插入数据很快
    - 无序，用哈希索引做区间查询很慢
    - 比如 Memcached 及其他一些 NoSQL 引擎
- 有序数组
  - 在等值查询和范围查询场景中的性能非常优秀
  - 用二分法可以快速找到对应的数据，O(Log(N))
  - 只适用于静态存储引擎
    - 插入数据慢，需要挪动插入的记录后面所有的记录
- 二叉搜索树
  - 特点
  - 父节点左子树所有节点的值小于父节点的值
  - 父节点右子树所有节点的值大于父节点的值
  - 需要保持这棵树是平衡二叉树
    - 查询复杂度O(log(N))
    - 更新复杂度O(log(N))
- N 叉树
  - B+ 树就是一种 N 叉树
  - 相比于二叉树，能够有效减少单次查询的磁盘访问次数
  - N 取决于数据块的大小
    - MySQL 5.6 以后可以通过 page 大小间接控制 N 的大小
  - 被广泛应用在数据库引擎中
- InnoDB 的索引模型
  - 使用了 B+ 树索引模型
  - 每一个索引在 InnoDB 里面对应一颗 B+ 树
  - 主键索引也被称为聚簇索引（clustered index）
    - 叶子节点内容是整行数据
    - 主键查询只需要搜索主键这颗 B+ 树
    - 整张表的数据其实就是存在主键索引中的，这就是“聚簇索引”的意思
  - 非主键索引也被称为二级索引（secondary index）
    - 叶子节点内容是主键的值
      - 如果把多个列联合起来搞成主键索引，那么二级索引里包含的主键也是多列
    - 普通索引查询需要先拿到主键，再到主键索引树搜索一次
      - 这个过程称为回表
  - 叶子节点是 page（数据页），一个页里面可以存多个行
    - 页大小 16k，则行个数 = 16k/行大小
  - 索引维护
    - 页分裂
      - 新增加一个数据页，挪动部分数据过去，空间利用率降低大概 50%
      - 不挪动数据的新增数据页操作不叫页分裂
    - 当相邻的两个数据页利用率很低的时候会做数据页合并
  - 主键
    - 建议使用自增主键
      - 建议设置 bigint unsigned
    - 使用业务主键的场景
      - 1. 只有一个索引
      - 2. 该索引必须是唯一索引
      - （典型的 KV 场景）
    - 没有主键的表，InnoDB 会默认创建一个 RowId 做主键
    - 加主键都会重建表
  - 索引只能定位到 page，page 内部是个有序数组，用二分法
    - 数据页中有页目录，页目录 key 为 id ，value 为槽位，二分搜索页目录定位到槽位中的行记录
    - 内存数据页和磁盘数据页是一一对应的，持久化的时候直接覆盖写进去
  - 叶子节点中的数据连接方式
    - 叶子内是单向链表
    - 叶子间是双向链表
- 什么时候需要重建索引
  - 索引可能因为删除操作、页分裂等原因，导致数据页有空洞
    - 即空间未释放
  - 重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，更省空间
- 思考题
  - 重建普通 k 索引
    - alter table T drop index k;
    - alter table T add index(k);
  - 重建主键索引
    - alter table T drop primary key;
    - alter table T add primary key(id);
  - 对于上面这两个重建索引的做法，说出你的理解。
    - 重建索引 k 的做法合理，可以达到省空间的目的
    - 重建主键的过程不合理
  - 如果有不合适的
    - 为什么？
      - 删除或创建主键都会将整个表重建，导致第一个语句白做
    - 更好的方法是什么？
      - 使用 alter table T engine=InnoDB 代替
        - 触发 MySQL 重建该表，并进行碎片处理
        - 5.6 版本以后支持 onlineddl，没有行锁，有 mdl 读锁
      - 在第 12 讲有分析 [[12｜为什么我的 MySQL 会“抖”一下？]]
